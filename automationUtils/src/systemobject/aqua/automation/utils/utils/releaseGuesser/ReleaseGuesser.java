package systemobject.aqua.automation.utils.utils.releaseGuesser;import java.util.Arrays;import org.apache.commons.lang.StringUtils;/** * Generic Class, can be used outside JSystem Project This Class is a tool to * set the current release version of the system *  * @author Itzhak.Hovav */public abstract class ReleaseGuesser {	/**	 * ENUM representing all current available releases with tools to	 * extract/convert from/to String and double and perform logical operations	 * such as "greater", "less", "equal ETC"	 * 	 * @author Itzhak.Hovav	 */	public enum AvailableReleases {		UNKNOWN("UNKNOWN"), REL_1_25("1.25"), REL_1_26("1.26"), REL_1_30("1.30"), REL_1_40(				"1.40"), REL_2_00("2.00"), REL_2_05("2.05"), REL_2_10("2.10"), REL_2_15(				"2.15"), REL_2_20("2.20"), REL_2_50("2.50"), REL_2_51("2.51"), REL_2_52(				"2.52"), REL_3_00("3.00"), REL_3_50("3.50"), REL_3_70("3.70"), REL_3_80(				"3.80"), REL_4_00("4.00"), REL_4_10("4.10"), REL_4_20("4.20"), REL_4_50(				"4.50"), REL_4_60("4.60"), REL_5_00("5.00"), REL_5_60("5.60"), REL_5_61(				"5.61"), REL_5_69("5.69"), REL_5_70("5.70"), REL_5_71("5.71"), REL_5_90(				"5.90"), REL_6_00("6.00"), REL_6_01("6.01"), REL_6_30("6.30"), REL_6_31(				"6.31"), REL_6_40("6.40"), REL_6_41("6.41"), REL_6_60("6.60"), REL_6_61(				"6.61"), REL_7_00("7.00"), REL_7_01("7.01");		private String rel;		AvailableReleases(String rel) {			this.rel = rel;		}		public String rel() {			return rel;		}		/**		 * returns a release from double value		 * 		 * @param releaseFromUser		 *            release as double value		 * @return AvailableReleases, the suitable release according to the		 *         given value		 */		public static AvailableReleases get(double releaseFromUser) {			String str = Double.toString(releaseFromUser);			if (str.contains(".")) {				String str2 = str.substring(str.indexOf('.') + 1);				if (str2.length() < 2) {					str = str + "0";				} else if (str2.length() > 2) {					str = str.substring(0, str.indexOf('.') + 1);					str2 = str2.substring(0, 2);					str = str + str2;				}			} else {				str = str + ".00";			}			return get(str);		}		/**		 * returns a release from String value		 * 		 * @param releaseFromUser		 *            release as String value		 * @return AvailableReleases, the suitable release according to the		 *         given value		 */		public static AvailableReleases get(String releaseFromUser) {			AvailableReleases[] avilableReleases = AvailableReleases.values();			for (int i = 0; releaseFromUser != null					&& i < avilableReleases.length; i++) {				if (avilableReleases[i].rel().equals(releaseFromUser.trim())) {					return avilableReleases[i];				}			}			return AvailableReleases.UNKNOWN;		}		/**		 * compare the current release to another AvailableReleases object		 * 		 * @param releaseFromUser		 *            another AvailableReleases object		 * @return boolean, true if the current release greater than the given		 *         one		 */		public boolean isGreaterThan(AvailableReleases releaseFromUser) {			if (releaseFromUser != AvailableReleases.UNKNOWN) {				return this.toDouble() > releaseFromUser.toDouble();			}			return false;		}		/**		 * compare the current release to another AvailableReleases object		 * 		 * @param releaseFromUser		 *            another AvailableReleases object		 * @return boolean, true if the current release greater than or equals		 *         to the given one		 */		public boolean isEqualGreaterThan(AvailableReleases releaseFromUser) {			return !isLessThan(releaseFromUser);		}		/**		 * compare the current release to another AvailableReleases object		 * 		 * @param releaseFromUser		 *            another AvailableReleases object		 * @return boolean, true if the current release equals to the given one		 */		public boolean isEqualTo(AvailableReleases releaseFromUser) {			if (releaseFromUser != AvailableReleases.UNKNOWN) {				return this.toDouble() == releaseFromUser.toDouble();			}			return false;		}		/**		 * compare the current release to another AvailableReleases object		 * 		 * @param releaseFromUser		 *            another AvailableReleases object		 * @return boolean, true if the current release less than or equals to		 *         the given one		 */		public boolean isEqualLessThan(AvailableReleases releaseFromUser) {			return !isGreaterThan(releaseFromUser);		}		/**		 * compare the current release to another AvailableReleases object		 * 		 * @param releaseFromUser		 *            another AvailableReleases object		 * @return boolean, true if the current release less than the given one		 */		public boolean isLessThan(AvailableReleases releaseFromUser) {			if (releaseFromUser != AvailableReleases.UNKNOWN) {				return toDouble() < releaseFromUser.toDouble();			}			return false;		}		@Override		public String toString() {			return rel;		}		/**		 * return the current release value as double		 * 		 * @return double, value of the current release as double		 */		public double toDouble() {			try {				return Double.parseDouble(rel);			} catch (Exception e) {				return 0.00D;			}		}	}	private static AvailableReleases[] availableReleases = AvailableReleases			.values();	/**	 * @param releaseFromUser	 *            the release before the "guess"	 * @return release after "guess"	 */	public static String guessRelease(String releaseFromUser) {		double sub = Double.MAX_VALUE;		int index = 0;		for (int i = 0; i < availableReleases.length; i++) {			double res = Math.abs(availableReleases[i].toDouble()					- Double.parseDouble(releaseFromUser));			if (res < sub) {				sub = res;				index = i;			}		}		return availableReleases[index].rel();	}	public static String toString(double releaseFromUser) {		AvailableReleases rel = AvailableReleases.get(releaseFromUser);		String val;		if (rel != null) {			val = rel.rel();		} else {			val = Double.toString(releaseFromUser);			if (val.contains(".")) {				String val2 = val.substring(val.indexOf('.') + 1);				if (val2.length() < 2) {					val = val + "0";				} else if (val2.length() > 2) {					val = val.substring(0, val.indexOf('.') + 1);					val2 = val2.substring(0, 2);					val = val + val2;				}			} else {				val = val + ".00";			}		}		return val;	}	public static Class<?> getLastImplementedFunctionality(String className,			double requiredRelease) {		int index = AvailableReleases.get(requiredRelease).ordinal();		for (int i = index; i >= 0; i--) {			try {				return Class.forName(className						+ availableReleases[i].rel.replace(".", "_"));			} catch (Exception e) {			}		}		return null;	}	public static Class<?> getLastImplementedCustomerConfig(			Class<?> desiredClass, double requiredRelease) {		return getLastImplementedCustomerConfig(desiredClass.getName(),				requiredRelease);	}	/**	 * Returns Class object with the required Customer configuration according	 * to the release.	 * 	 * @param className	 * @param requiredRelease	 * @return	 */	public static Class<?> getLastImplementedCustomerConfig(String className,			double requiredRelease) {		int index = AvailableReleases.get(requiredRelease).ordinal();		String editedClassNamePrefix = null;		String editedClassNameSuffix = null;		String editedClassName = null;		/**		 * If old package name, add the .rel_to package name		 */		if (className.contains(".rel_")) {			String[] splitResult = className.split(".rel_");			editedClassNamePrefix = (splitResult[0] + ".rel_");			editedClassNameSuffix = ("." + splitResult[1].split("\\.")[1]);		} else {			editedClassNamePrefix = (className.substring(0,					className.lastIndexOf(".")) + ".rel_");			editedClassNameSuffix = (className.substring(					className.lastIndexOf("."), className.length()));		}		for (int i = index; i >= 0; i--) {			try {				editedClassName = (editedClassNamePrefix						+ availableReleases[i].rel.replace(".", "_") + editedClassNameSuffix);				return Class.forName(editedClassName);			} catch (Exception e) {				/**				 * Case of not found, try to add the release to the class name				 */				if (editedClassName.contains("_Rel_")) {					String[] temp = editedClassName.split("_Rel_");					editedClassName = temp[0] + "_Rel_"							+ availableReleases[i].rel.replace(".", "_");				} else {					editedClassName += "_Rel_"							+ availableReleases[i].rel.replace(".", "_");				}				try {					return Class.forName(editedClassName);				} catch (ClassNotFoundException e1) {				}			}		}		return null;	}	public static boolean isReleaseLessThan(String release, double otherRelease) {		return (compareRelease(release, Double.toString(otherRelease), false) < 0);	}	public static boolean isReleaseLessThan(String release, String otherRelease) {		return (compareRelease(release, otherRelease,				(StringUtils.countMatches(release, ".") > 1 || StringUtils						.countMatches(otherRelease, ".") > 1)) < 0);	}	public static boolean isReleaseGreaterThan(String release,			double otherRelease) {		return (compareRelease(release, Double.toString(otherRelease), false) > 0);	}	public static boolean isReleaseGreaterThan(String release,			String otherRelease) {		return (compareRelease(release, otherRelease,				(StringUtils.countMatches(release, ".") > 1 || StringUtils						.countMatches(otherRelease, ".") > 1)) > 0);	}	private static int compareRelease(String release, String otherRel,			boolean withInnerBuilds) {		String[] rel = release.split("\\.");		String[] oth = otherRel.split("\\.");		while (rel.length < (withInnerBuilds ? 3 : 2)) {			rel = Arrays.copyOf(rel, rel.length + 1);			rel[rel.length - 1] = "0";		}		while (oth.length < (withInnerBuilds ? 3 : 2)) {			oth = Arrays.copyOf(oth, oth.length + 1);			oth[oth.length - 1] = "0";		}		String thisRel = "";		otherRel = "";		thisRel += Integer.toString(Integer.parseInt(rel[0]) + 10000)				.substring(1);		otherRel += Integer.toString(Integer.parseInt(oth[0]) + 10000)				.substring(1);		thisRel += Integer.toString(Integer.parseInt(rel[1]) + 10000)				.substring(1);		otherRel += Integer.toString(Integer.parseInt(oth[1]) + 10000)				.substring(1);		if (withInnerBuilds) {			thisRel += Integer.toString(Integer.parseInt(rel[2]) + 10000)					.substring(1);			otherRel += Integer.toString(Integer.parseInt(oth[2]) + 10000)					.substring(1);		}		return thisRel.compareTo(otherRel);	}}