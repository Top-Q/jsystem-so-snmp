package systemobject.aqua.automation.utils.analyzers;import jsystem.framework.analyzer.AnalyzerParameterImpl;/** * Comper to int values or 2 int [] *  * @author Itzhak.Hovav */public class CompareAnalyzer extends AnalyzerParameterImpl {	private long actual;	private long expected;	private int[] actualArr;	private int[] expectedArr;	private int state;	@SuppressWarnings("unused")	private Object extraData;	private double error;	private final int STATE_VAL = 0;	private final int STATE_ARR = 1;	private final int STATE_NotEQUAL = 2;	private final int CHECK_WITH_ERROR_PERCENTAGE = 3;	private final int CHECK_WITH_ERROR_RANGE = 4;	private final int STATE_BIGGER = 5;	private double min;	private double value;	private double max;	/**	 * @author Itzhak.Hovav	 */	public static enum EnumCompare {		Equal, NotEqual, Bigger;	}	public CompareAnalyzer(int actual, int expected, EnumCompare type) {		setTestAgainst(type);		switch (type) {		case Equal:			init(actual, expected, null);			break;		case NotEqual:			init(actual, expected);			break;		case Bigger:			this.actual = actual;			this.expected = expected;			state = STATE_BIGGER;			break;		default:			break;		}	}	public CompareAnalyzer(int actual, int expected, EnumCompare type,			double error) {		setTestAgainst(type);		switch (type) {		case Equal:			init(actual, expected, error);			break;		case NotEqual:			init(actual, expected);			break;		case Bigger:			this.actual = actual;			this.expected = expected;			state = STATE_BIGGER;			break;		default:			break;		}	}	public CompareAnalyzer(int actual, int expected, EnumCompare type,			long error) {		setTestAgainst(type);		switch (type) {		case Equal:			init(actual, expected, error);			break;		case NotEqual:			init(actual, expected);			break;		case Bigger:			this.actual = actual;			this.expected = expected;			state = STATE_BIGGER;			break;		default:			break;		}	}	public void init(int actual, int expected, Object failExtraData) {		this.actual = actual;		this.expected = expected;		state = STATE_VAL;		this.extraData = failExtraData;	}	public void init(int actual, int expected) {		this.actual = actual;		this.expected = expected;		state = STATE_NotEQUAL;	}	public CompareAnalyzer(int actual, int expected, Object failExtraData) {		init(actual, expected, failExtraData);	}	public void init(long actual, long expected, double error) {		this.actual = actual;		this.expected = expected;		state = CHECK_WITH_ERROR_PERCENTAGE;		this.error = error;		this.extraData = "";	}	public CompareAnalyzer(long actual, long expected, double error) {		init(actual, expected, error);	}	public void init(long actual, long expected, long error) {		this.actual = actual;		this.expected = expected;		state = CHECK_WITH_ERROR_RANGE;		this.error = error;		this.extraData = "";	}	public CompareAnalyzer(long actual, long expected, long error) {		init(actual, expected, error);	}	public CompareAnalyzer(int actual, int expected) {		init(actual, expected);	}	public CompareAnalyzer(int[] actual, int[] expected, Object failExtraData) {		this.actualArr = actual;		this.expectedArr = expected;		state = STATE_ARR;		this.extraData = failExtraData;	}	public void analyze() {		if ((actualArr != null && expectedArr != null)				&& (actualArr.length != expectedArr.length)) {			message = "Arrays have different length";			status = false;		} else {			switch (state) {			case STATE_NotEQUAL:				if (actual != expected) {					status = true;					title = "Actual value:" + actual							+ "  not equal to  Expected value: " + expected;				} else {					status = false;					title = "Actual value:" + actual							+ "  equal to  Expected value: " + expected;				}				break;			case STATE_BIGGER:				if (actual > expected) {					status = true;					title = "Actual value:" + actual							+ "  BIGGER then  Expected value: " + expected;				} else {					status = false;					title = "Actual value:" + actual							+ "  NOT BIGGER the  Expected value: " + expected;				}				break;			case STATE_ARR:				status = true;				message = "Actual array :";				for (int i = 0; i < actualArr.length; i++) {					message += actualArr[i] + "  ";				}				message += "\n\r" + "Expected array :";				for (int i = 0; i < expectedArr.length; i++) {					message += expectedArr[i] + "  ";					if (expectedArr[i] != actualArr[i]) {						status = false;					}				}				title = "Compare 2 arrays";				break;			case CHECK_WITH_ERROR_PERCENTAGE:				min = (1 - error) * expected;				max = (1 + error) * expected;				if (actual >= min && actual <= max) {					status = true;				} else {					status = false;				}				title = "Actual value:" + actual + "  Expected value: "						+ expected;				break;			case CHECK_WITH_ERROR_RANGE:				min = expected - error;				max = expected + error;				if (actual >= min && actual <= max) {					status = true;				} else {					status = false;				}				title = "Actual value:" + actual + "  Expected value: "						+ expected;				break;			default:				title = "Actual value:" + actual + "  Expected value: "						+ expected;				if (actual == expected) {					status = true;				} else {					status = false;					message = "Fail accured : Actual value " + actual							+ "  not equal to expected value " + value;				}				break;			}		}	}}