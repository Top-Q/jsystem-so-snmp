package systemobject.aqua.automation.utils.utils.stepReport;import java.io.File;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput;import java.text.SimpleDateFormat;import javax.xml.parsers.DocumentBuilderFactory;import jsystem.extensions.report.html.LevelHtmlTestReporter;import jsystem.framework.common.CommonResources;import jsystem.framework.report.ListenerstManager;import jsystem.framework.report.Reporter;import jsystem.framework.report.Reporter.EnumReportLevel;import jsystem.framework.report.TestInfo;import jsystem.framework.scenario.JTestContainer;import jsystem.framework.scenario.flow_control.AntForLoop;import jsystem.utils.DateUtils;import jsystem.utils.FileUtils;import junit.framework.AssertionFailedError;import junit.framework.Test;import org.w3c.dom.Document;import org.w3c.dom.Element;import systemobject.aqua.automation.utils.db.utils.SqlEscapeUtils;import com.sun.org.apache.xpath.internal.XPathAPI;/** * JSystem Class, cannot be used outside JSystem Project this class extends the * "LevelHtmlTestReporter" reporter and add the ability to open and close steps * that will get their statuses from the reports that will be received during * the time period that step was opened. steps IDs with their statuses will be * written to a XML file under "log\current" location - so for each runner * execution it will be initiated from the beginning *  * @author Itzhak.Hovav */public class Stepper extends LevelHtmlTestReporter {	/**	 * enum represents all possible step statuses including mapping to the	 * relative reporter int value and to int weight	 * 	 * @author Itzhak.Hovav	 */	public enum StepStatus {		pass(0, Reporter.PASS), warning(1, Reporter.WARNING), fail(2,				Reporter.FAIL);		private int value;		private int reporterIntVal;		private static final StepStatus[] all = values();		StepStatus(int value, int reporterIntVal) {			this.value = value;			this.reporterIntVal = reporterIntVal;		}		public int value() {			return value;		}		public int reporterIntVal() {			return reporterIntVal;		}		public static StepStatus get(int reporterIntVal) {			for (int i = 0; i < all.length; i++) {				if (all[i].reporterIntVal() == reporterIntVal) {					return all[i];				}			}			return StepStatus.fail;		}	}	/**	 * date formatter for adding "time" tag to the "level" report	 */	private static SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");	/**	 * value representing start step in the "start level" method	 */	public static final int START_STEP = Integer.MAX_VALUE;	/**	 * value representing stop step in the "start level" method	 */	public static final int STOP_STEP = Integer.MIN_VALUE;	/**	 * value representing initial parameters in the "start level" method	 */	public static final int INITIAL_PARAMS = Integer.MAX_VALUE - 1;	/**	 * value representing ignore in the "start level" method	 */	public static final int IGNORE = Integer.MAX_VALUE - 2;	/**	 * value representing seperator inside a level report when sending a step	 * report in the "start level" method	 */	public static final String STEP_KEY_SEPERATOR = ";<STEP_KEY_SEPERATOR>;";	/**	 * step id as string	 */	private String stepId = null;	/**	 * indicates if the test is in teardown or not	 */	private boolean inTearDown = false;	/**	 * current step status	 */	private StepStatus stepStatus = null;	/**	 * current step description	 */	private String stepDescription = null;	/**	 * indicates if the it should ignore reports	 */	private boolean ignore = false;	/**	 * XML file main	 */	private Element main = null;	/**	 * XML file current test	 */	private Element test = null;	/**	 * XML file document	 */	private Document doc = null;	/**	 * actual XML file	 */	private File reportFile = null;	/**	 * file name	 */	public static final String fileNmae = "runStepsInfo.xml";	/**	 * current test name	 */	@SuppressWarnings("unused")	private String testName = null;	/**	 * default empty CTOR	 * 	 * @throws Exception	 */	public Stepper() throws Exception {		super();	}	/**	 * init the Stepper variables including file, document, main and test.	 * 	 * @param testName	 *            current test full name (along with its package)	 * @param release	 *            release as String	 * @throws Exception	 */	public void initStepper(String testName, String release, String testStepId)			throws Exception {		this.testName = testName;		this.inTearDown = false;		this.stepStatus = null;		this.ignore = false;		String currentTestFolder = ListenerstManager.getInstance()				.getCurrentTestFolder().replace('\\', '/').trim();		if (currentTestFolder.endsWith("" + '/')) {			currentTestFolder = currentTestFolder.substring(0,					currentTestFolder.length() - 1);		}		File folder = new File(currentTestFolder.substring(0,				currentTestFolder.lastIndexOf('/') + 1)				+ "/publishInfo");		if (!folder.exists()) {			folder.mkdir();		}		reportFile = new File(currentTestFolder.substring(0,				currentTestFolder.lastIndexOf('/') + 1)				+ "/publishInfo/" + fileNmae);		if (reportFile.exists()) {			doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()					.parse(reportFile);		} else {			doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()					.newDocument();			main = doc.createElement("tests");			doc.appendChild(main);		}		main = (Element) XPathAPI.selectSingleNode(doc, "tests");		test = doc.createElement("test");		test.setAttribute("index",				Integer.toString(main.getChildNodes().getLength() / 2));		test.setAttribute("name", testName);		test.setAttribute("release", release);		if (testStepId != null && !testStepId.equals("null")				&& !testStepId.equals("")) {			test.setAttribute("id", testStepId);		}		main.appendChild(test);		writeXml();	}	@Override	public void endTest(String packageName, String testName, String methodName,			long time) {		synchronized (this) {			stopStep();			super.endTest(packageName, testName, methodName, time);		}	}	//	// public void reportWithoutLevel(String title, String message, int status,	// boolean bold, boolean html, boolean link) {	// decide(title, status);	// super.reportWithoutLevel(title, message, status, bold, html, link);	// }	@Override	public void report(String title, String message, int status, boolean bold,			boolean html, boolean link) {		decide(title, status);		synchronized (this) {			super.report(title, message, status, bold, html, link);		}	}	@Override	public void report(String title, String message, boolean isPass,			boolean bold, boolean ignore) {		decide(title, isPass);		synchronized (this) {			super.report(title, message, isPass, bold, ignore);		}	}	/**	 * stops, closes the current step and init variables for next step	 */	private void stopStep() {		if (stepStatus != null && stepId != null) {			synchronized (this) {				// switchToMainFrame();				closeAllLevels();				Element step = doc.createElement("step");				step.setAttribute("id", stepId);				step.setAttribute("status", stepStatus.toString());				step.setAttribute("description",						SqlEscapeUtils.escapeMySqlString(stepDescription));				test.appendChild(step);				writeXml();				stepStatus = null;				stepId = null;				ignore(false);			}		}	}	/**	 * closes current step if any and opens a new step with the given step key	 * ID	 * 	 * @param stepKey	 *            Step key as String	 */	private void startStep(String stepKey, String description) {		synchronized (this) {			if (stepStatus != null) {				stopStep();			}			stepId = stepKey;			stepStatus = StepStatus.pass;			stepDescription = description;		}	}	@Override	public void addWarning(Test test) {		synchronized (this) {			setStepDecision(StepStatus.warning);			super.addWarning(test);		}	}	@Override	public void endRun() {		synchronized (this) {			stopStep();			super.endRun();		}	}	@Override	public void addError(Test test, Throwable t) {		synchronized (this) {			setStepDecision(StepStatus.fail);			super.addError(test, t);		}	}	@Override	public void addFailure(Test test, AssertionFailedError t) {		synchronized (this) {			setStepDecision(StepStatus.fail);			super.addFailure(test, t);		}	}	@Override	public String getName() {		return "Level Html Reporter With Steps Support";	}	/**	 * set test status according to a single report	 * 	 * @param title	 *            current report string	 * @param status	 *            boolean represent report status	 */	protected void decide(String title, boolean status) {		decide(title, status ? Reporter.PASS : Reporter.FAIL);	}	/**	 * set test status according to a single report	 * 	 * @param title	 *            current report string	 * @param status	 *            int represent report status	 */	protected void decide(String title, int status) {		decide(title, StepStatus.get(status));	}	/**	 * set test status according to a single report	 * 	 * @param title	 *            current report string	 * @param status	 *            local ENUM represent report status	 */	protected void decide(String title, StepStatus status) {		synchronized (this) {			// Fix for Jsystem 5.4			inTearDown = (inTearDown | title					.contains(CommonResources.TEARDOWN_STRING));			if (!ignore) {				if (inTearDown && title.contains("Fail report was submitted")) {					stopStep();				} else if (inTearDown && title.contains("Start time:")) {					setStepDecision(StepStatus.fail);					stopStep();				} else {					setStepDecision(status);				}			}		}	}	/**	 * sets the step status regarding the old status and the current given one	 * 	 * @param status	 *            status of the step	 */	protected void setStepDecision(StepStatus status) {		synchronized (this) {			if (!ignore && stepStatus != null && stepId != null					&& status != null && status.value() > stepStatus.value()) {				stepStatus = status;			}		}	}	/**	 * perform actual file writing	 */	protected void writeXml() {		synchronized (this) {			try {				FileUtils.saveDocumentToFile(doc, reportFile);			} catch (Exception e) {			}		}	}	/**	 * when true - the reporter will ignore all incoming reports and will not	 * take their statuses under consideration when deciding about the step	 * status	 * 	 * @param ignore	 *            true for ignore, false for not	 */	protected void ignore(boolean ignore) {		this.ignore = ignore;	}	/**	 * returns if the reporter is in "ignore" status or not	 * 	 * @return boolean - ignore status	 */	protected boolean isIgnore() {		return this.ignore;	}	@Override	public void startLevel(String levelName, int place) throws IOException {		synchronized (this) {			int keyIndex;			switch (place) {			case (START_STEP):				stopStep();				place = Reporter.MainFrame;				keyIndex = levelName.indexOf(STEP_KEY_SEPERATOR);				String id = levelName.substring(0, keyIndex).trim();				levelName = levelName.substring(						keyIndex + STEP_KEY_SEPERATOR.length()).trim();				String description = levelName.replace("</font>", "")						.replace("<font size='2'>", "").replace("</a>", "")						.replace("<br>", "").replace("<b>", "")						.replace("</b>", "").replace("&nbsp;", " ");				while (description.contains("  ")) {					description = description.replace("  ", " ");				}				if (description.indexOf("Step Description: ") != -1) {					description = description.substring(							description.indexOf("Step Description: ")									+ ("Step Description: ").length()).trim();				} else {					description = "No Description Provided";				}				startStep(id, description);				break;			case (STOP_STEP):				stopStep();				return;			case (IGNORE):				ignore = (levelName.equals(Boolean.toString(true)));				return;			case (INITIAL_PARAMS):				try {					String testName = null;					String release = null;					String testStepId = null;					keyIndex = levelName.indexOf(STEP_KEY_SEPERATOR);					if (keyIndex != -1) {						testName = levelName.substring(0, keyIndex).trim();						levelName = levelName.substring(keyIndex								+ STEP_KEY_SEPERATOR.length());						keyIndex = levelName.indexOf(STEP_KEY_SEPERATOR);						if (keyIndex != -1) {							release = levelName.substring(0, keyIndex).trim();							levelName = levelName.substring(keyIndex									+ STEP_KEY_SEPERATOR.length());							keyIndex = levelName.indexOf(STEP_KEY_SEPERATOR);							if (keyIndex != -1) {								testStepId = levelName.substring(0, keyIndex)										.trim();							} else if (!levelName.trim().equals("")) {								testStepId = levelName;							}						} else {							release = levelName;						}					} else {						testName = levelName;					}					initStepper(testName, release, testStepId);				} catch (Exception e) {					throw new IOException(e);				}				return;			}			levelName = (DateUtils.getDate(System.currentTimeMillis(), sdf)					+ ": " + levelName);			super.startLevel(levelName, place);		}	}	public void stopLevel() {		synchronized (this) {			super.stopLevel();		}	}	public void closeAllLevels() {		synchronized (this) {			super.closeAllLevels();		}	}	public void closeLevelsUpTo(String levelName, boolean includeLevel) {		synchronized (this) {			super.closeLevelsUpTo(levelName, includeLevel);		}	}	public void report(String title, String message, boolean status,			boolean bold) {		synchronized (this) {			super.report(title, message, status, bold);		}	}	public void saveFile(String fileName, byte[] content) {		synchronized (this) {			super.saveFile(fileName, content);		}	}	public void report(String title, String message, int status, boolean bold) {		synchronized (this) {			super.report(title, message, status, bold);		}	}	public void addProperty(String key, String value) {		synchronized (this) {			super.addProperty(key, value);		}	}	public void endTest(Test test) {		synchronized (this) {			super.endTest(test);		}	}	public void startTest(TestInfo testInfo) {		synchronized (this) {			super.startTest(testInfo);		}	}	public void startTest(Test test) {		synchronized (this) {			super.startTest(test);		}	}	public void startSection() {		synchronized (this) {			super.startSection();		}	}	public void endSection() {		synchronized (this) {			super.endSection();		}	}	public void setData(String data) {		synchronized (this) {			super.setData(data);		}	}	@Override	public void readExternal(ObjectInput in) throws IOException,			ClassNotFoundException {		synchronized (this) {			super.readExternal(in);		}	}	@Override	public void writeExternal(ObjectOutput out) throws IOException {		synchronized (this) {			super.writeExternal(out);		}	}	@Override	public void endContainer(JTestContainer container) {		synchronized (this) {			super.endContainer(container);		}	}	@Override	public void endLoop(AntForLoop loop, int count) {		synchronized (this) {			super.endLoop(loop, count);		}	}	@Override	public void startContainer(JTestContainer container) {		synchronized (this) {			super.startContainer(container);		}	}	@Override	public void startLoop(AntForLoop loop, int count) {		synchronized (this) {			super.startLoop(loop, count);		}	}	public void startLevel(String level, EnumReportLevel place)			throws IOException {		synchronized (this) {			super.startLevel(level, place);		}	}}